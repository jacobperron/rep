REP: 2010
Title: Service Introspection
Author: Jacob Perron <jacob@openrobotics.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 07-Jun-2022
Post-History:

Abstract
========

This REP proposes a feature to introspect ROS services during runtime.
The feature allows users to remotely monitor service requests and responses.


Terminology
===========

:Service:
  A ROS service.
  Accepts requests from clients and sends responses.
:Client:
  A ROS service client.
  Sends requests to services and receives responses.
:Request:
  A ROS service request.
:Response:
  A ROS service response.


Motivation
==========

The primary motivation for this proposal is to make it easier for users to externally validate that services are operating as expected.
Drawing an analogy to ROS topics, there exists tools and libraries for "echoing" and recording messages sent over a topic, and we would like to see the same kind of capabilities for services.
Specifically, we want the capability to introspect requests and responses that are sent to and from services and clients.
Being able to remotely monitor services allows users to more effectively troubleshoot issues in a ROS system.
For example, we could verify requests are being received by a service by employing a command-line tool during runtime.
Or, we could post-process recorded requests and responses to validate their content.

There are additional features that could leverage this proposal, such as:

- Playback of recorded services (for example, from a rosbag [1]_)
- Introspection of ROS actions, which are built on services
- Validation of a live ROS system by referencing a recording from a previous session

Though this proposal focuses on the core feature of introspecting requests and responses, we want to keep the design flexible so additional features like those listed above can be implemented in the future.


Specification
=============

Publishing Service Events
-------------------------

Whenever a request or response is sent or received, a *service event* message will be published to a topic.
Services are responsible for publishing a message when they receive a request and when they send a response.
Likewise, clients are responsible for publishing a message when they send a request and when they receive a response.
Therefore, we have a total of four possible events:

:Request Sent:
  Emitted from a client after sending a request to a service.
:Request Received:
  Emitted from a service after receiving a request from a client.
:Response Sent:
  Emitted from a service after sending a response to a client.
:Response Received:
  Emitted from a client after receiving a response from a service.

Request event messages shall be published to the hidden topic ``/SERVICE_NAME/_request_event``, where ``SERVICE_NAME`` is the fully-qualified name of the service.
Similarly, response event messages shall be published to the hidden topic ``/SERVICE_NAME/_response_event``.
Note that this implies that services must have unique names.

By publishing service event messages to predetermined topics, tools and libraries are able to subscribe to these topics to inspect the flow of data between services.

Service Event Definitions
-------------------------

For each service definition, ``my/srv/Foo``, we define two new ROS message types using the ROS IDL specification [2]_:

:my/msg/Foo_RequestEvent:
  This type communicates a request sent or request received event.

  .. code-block::

     # Indicates this request event was emitted from a client
     uint8 CLIENT_SENT     = 0

     # Indicates this request event was emitted from a service
     uint8 SERVICE_RECEIVED = 1

     # Whether this is a CLIENT_SENT or SERVICE_RECEIVED event.
     uint8 request_type

     # Timestamp for when the event occurred (sent or received time)
     builtin_interfaces/Time stamp

     # Unique identifier for the client that sent the request
     # Note, this is only unique for the current session
     unique_identifier_msgs/msg/UUID client_id

     # Sequence number for the request
     # Combined with the client ID, this creates a unique ID for the request
     int64 sequence_number

     # The actual request content sent or received
     # Setting this field is optional
     my/srv/Foo_Request request

:my/msg/Foo_ResponseEvent:
  This type communicates a response sent or response received event.

  .. code-block::

     # Indicates this response event was emitted from a service
     uint8 SERVICE_SENT     = 0

     # Indicates this response event was emitted from a client
     uint8 CLIENT_RECEIVED = 1

     # Whether this is a SERVICE_SENT or CLIENT_RECEIVED event.
     uint8 response_type

     # Timestamp for when the event occurred (sent or received time)
     builtin_interfaces/Time stamp

     # Unique identifier for the client that sent the request associated with this response
     # Note, this is only unique for the current session
     unique_identifier_msgs/msg/UUID client_id

     # Sequence number for the request associated with this response
     # Combined with the client ID, this creates a unique ID for the request
     int64 sequence_number

     # The actual response content sent or received
     # Setting this field is optional
     my/srv/Foo_Response response

Note, we put the service event definitions into the ``msg`` namespace, as this expected for message interface types in many libraries and tools in the ROS ecosystem.

The service event definitions are generated as part of the ``rosidl`` pipeline [3]_.

Timestamp
^^^^^^^^^
Timestamps represent the time at which the event occurred.
I.e. they are set to the time directly after a request or response is sent or received.

Timestamps shall respect ROS time [4]_.
This means by default they will by set with wall-time.
If simulation time is enabled by the node implementing the service or client, then timestamps will get their time from the ``/clock`` topic.

Client ID and sequence number
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Both the client ID and sequence number are provided by the ROS middleware [5]_.
They can be accessed from ``rcl`` [6]_ when taking a request or response for a service or client respectively.

Example
^^^^^^^

For example, consider a service ``example_interfaces/srv/AddTwoInts`` defined as follows:

.. code-block::

   int64 a
   int64 b
   ---
   int64 sum

The following service event message definitions are generated when building the ``example_interfaces`` package (comments elided for brevity):

:example_interfaces/msg/AddTwoInts_RequestEvent:

.. code-block::

   uint8 REQUEST_SENT     = 0
   uint8 REQUEST_RECEIVED = 1

   uint8 request_type

   builtin_interfaces/Time stamp

   unique_identifier_msgs/msg/UUID client_id

   int64 sequence_number

   example_interfaces/srv/AddTwoInts_Request request

:example_interfaces/msg/AddTwoInts_ResponseEvent:

.. code-block::

   uint8 RESPONSE_SENT     = 0
   uint8 RESPONSE_RECEIVED = 1

   uint8 response_type

   builtin_interfaces/Time stamp

   unique_identifier_msgs/msg/UUID client_id

   int64 sequence_number

   example_interfaces/srv/AddTwoInts_Response response

The definition for ``example_interfaces/srv/AddTwoInts_Request`` is,

.. code-block::

   int64 a
   int64 b

And the definitions for ``example_interfaces/srv/AddTwoInts_Reponse`` is,

.. code-block::

   int64 sum

Configuration
-------------

Configuration of service introspection features will be done through ROS parameters.

.. code-block:: yaml

   /NODE_NAME:
      ros__parameters:
         
         # Indicates if CLIENT_SENT and CLIENT_RECEIVED events will be published
         SERVICE_NAME/client_events_enabled: bool

         # Indicates if SERVICE_SENT and SERVICE_RECEIVED events will be published
         SERVICE_NAME/service_events_enabled: bool
         
         # Indicates if request content will be included in CLIENT_SENT RequestEvent messages
         SERVICE_NAME/_enable_client_sent_content: bool

         # Indicates if request content will be included in SERVICE_RECEIVED RequestEvent messages
         SERVICE_NAME/_enable_service_receive_content: bool

         # Indicates if response content will be included in SERVICE_SENT RequestEvent messages
         SERVICE_NAME/_enable_service_sent_content: bool

         # Indicates if response content will be included in CLIENT_RECEIVED RequestEvent messages
         SERVICE_NAME/_enable_client_receive_content: bool
         
         # Indicates if service introspection will be enabled for default services
         _enable_default_service_introspection: bool 


Security
--------

Enabling service introspection creates more attack surface for an existing ROS system by adding 2*N more topics (where N is the number of services with the feature enabled).
These topics are vulnerable to undesired actors listening in on service communication or even interfering with parts of the system they may be relying on service events.

Luckily, we can leverage the existing security feature for topics in ROS 2 (see SROS 2 [7]_).
Any existing tooling for aiding users in setting up ROS security should consider the new service event topics (e.g. NoDL [8]_).


Rationale
=========


Using ROS Parameters for configuration
--------------------------------------
ROS parameters provide a well-known and supported way of interacting with node-level settings at various points in a node's lifecycle.
A user may want to avoid the overhead of publishing service event messages during normal operation,
so it is desirable to be able to enable service introspection features during runtime.
There is existing tooling to work with parameters on a per-node basis such as the ``parameter_client`` API in ``rclcpp`` or ``rclpy`` as well as for groups of nodes in ``ros2 launch`` or all nodes using wildcards in ``YAML`` parameter files [10]_.
This makes ROS parameters the ideal choice as opposed to using environment variables or some other custom implementation.


Default Services
----------------

ROS 2 parameters are built on top of ROS 2 service/clients and already publish out to ``/parameter_events`` on parameter changes [11]_.
As parameters can be set directly by the host as well as through the corresponding parameter service, the service introspection proposed by this REP would fail to capture a subset of parameter events.
For this reason service introspection will be disabled by default for ROS 2 parameters in favour of ``/parameter_events``. 
This behavior can be changed through `a parameter <Configuration_>`_ if desired.


Only supporting one service per name
------------------------------------
It is technically possible to create more than one service on a given name (though not recommended).
This use case will not be supported since enabling service introspection in such a case would result in ambiguous behaviour.


Separate request and response events instead of single service event
--------------------------------------------------------------------

Separate events for requests and responses will be published instead of a single service event or 
publishing an unique event for clients and services (for a total of 4 event types).
This is to best balance avoiding introducing additional topic surface area and complexity of consuming emitted introspection data. 
Grouping events by request or response rather than by client or subscriber would also ease request/response tracing work.

.. Concern: our enable flags are enable by serv/client but our messages are grouped via req/response. Could be confusing?


Optional content
----------------

Duplicating request or response content will be optional as service response messages can be *very* large and flooding the ROS network with up to four copies of the same message can introduce undesirable load and latency.
By default content will be included on ``CLIENT_SENT`` and ``SERVICE_SENT``. 


Backwards Compatibility
=======================

Service introspection is a new feature which is not planned to impact any existing logic. 
It is also an opt-in feature so there will be no additional incurred overhead by default.
As always, code written to take advantage of this new feature will not be backwards compatible (at least regarding this feature) with versions of ROS 2 that do not have it implemented.


Other
=====


Tooling
----------------------

``ros2 service``
^^^^^^^^^^^^^^^^
The existing ``ros2 service`` tool can be extended using an ``echo`` keyword to monitor service events.
Internally, it would subscribe to the `hidden topics <Publishing Service Events_>`_ and echo them.
The existing command line parameters for topics can be extended to be used with this ``echo`` verb, along with new
arguments on to filter message content and analyse delays.

Building off the example with AddTwoInts discussed earlier, an example ``ros2 service echo`` call may look like the following:

.. code-block::

   $ ros2 service echo /add_two_ints
   -----------------------
   request_type: REQUEST_SENT
   stamp: 1.00
   client_id: 1234
   sequence_number: 1
   request:
      a: 1
      b: 2
   -----------------------
   request_type: REQUEST_RECEIVED
   stamp: 1.10
   client_id: 1235
   sequence_number: 1
   request:
      a: 1
      b: 2
   -----------------------
   request_type: RESPONSE_SENT
   stamp: 1.20
   client_id: 1235
   sequence_number: 2
   request:
      sum: 3
   -----------------------
   request_type: RESPONSE_RECEIVED
   stamp: 1.30
   client_id: 1234
   sequence_number: 2
   request:
      sum: 3
   -----------------------


``ros2 bag``
^^^^^^^^^^^^

``rosbag2`` integration for service introspection will come more or less for free since the request/response events are simply being echoed through ROS 2 publishers.
Syntactic sugar may be included to enable service introspection and record, e.g. ``ros2 bag record --enable-services``.

Replaying service and client events
-----------------------------------

The design should support implementation of a tool for "replaying" service and client events. 
For example, tooling may be developed to take the recorded event stream and replay requests and responses back into the ROS network.


References
==========

.. [1] rosbag2
   (https://github.com/ros2/rosbag2)

.. [2] ROS interface definitions
   (https://design.ros2.org/articles/legacy_interface_definition.html)

.. [3] ROS IDL pipeline
   (https://github.com/ros2/rosidl)

.. [4] ROS Time
   (https://design.ros2.org/articles/clock_and_time.html)

.. [5] RMW
   (https://github.com/ros2/rmw)

.. [6] rcl
   (https://github.com/ros2/rcl)

.. [7] SROS 2
   (https://github.com/ros2/sros2)

.. [8] NoDL
   (https://github.com/ubuntu-robotics/nodl)

.. [9] Launch
   (https://github.com/ros2/launch)

.. [10] YAML parameter file wildcard
   (https://docs.ros.org/en/rolling/Tutorials/Launch/Using-ROS2-Launch-For-Large-Projects.html#using-wildcards-in-yaml-files)

.. [11] Parameter Events
   (https://design.ros2.org/articles/ros_parameters.html)



Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:





